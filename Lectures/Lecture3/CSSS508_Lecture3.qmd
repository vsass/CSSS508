---
date-format: long
highlight-style:  a11y-dark 
footnotes-hover: true
reference-location: margin
execute: 
  echo: true
  message: false
  warning: false
  fig-format: "svg"
format: 
  revealjs:
    theme: lecture_styles.scss
    controls: true
    slide-number: true
    code-link: true
    chalkboard: true
    incremental: false 
    smaller: true
    preview-links: true
    code-line-numbers: true
    history: false
    progress: true
    link-external-icon: true
---

```{r}
#| echo: false
#| cache: false
require(downlit)
require(xml2)
require(tidyverse)
```

## {#title-slide data-menu-title="Workflow & Reproducibility" background="#1e4655" background-image="../../images/csss-logo.png" background-position="center top 5%" background-size="50%"}

[Workflow & Reproducibility]{.custom-title}

[CS&SS 508 • Lecture 3]{.custom-subtitle}

[17 October 2023]{.custom-subtitle2}

[Victoria Sass]{.custom-subtitle3}

# Roadmap{.section-title background-color="#99a486"}

---

<br>

Last time, we learned about,

* The `tidyverse`
* Basics of `ggplot2`
* Advanced features of `ggplot2`
* Extensions of `ggplot2`

. . . 

Today, we will cover,

* Code Style
* Workflow 
* Reproducibility
* Useful Base `R`

# Code Style{.section-title background-color="#99a486"}

## Naming Variables 

It's good practice to name variables using only lowercase letters, numbers, and `_` (to separate words). 

. . . 

Remember to give them descriptive names, even if that means they're longer. 

. . . 

If you have many related variables, try and be consistent with your naming convention. 

* A common prefix is preferable to a common suffix due to RStudio's autocomplete feature. 

```{r}
#| eval: false
# Code goal: 
short_flights <- flights |> 
  filter(air_time < 60)

# Code foul: 
SHORTFLIGHTS <- flights |> 
  filter(air_time < 60)
```

## Spacing 

For readability you'll want to put spaces around all mathematical operators^[except for `^`] (i.e. `+`, `-`, `==`, `<`, etc.) as well as the assignment operator (`<-`). 

```{r}
#| eval: false
# Code goals: 
z <- (a + b)^2 / d
mean(x, na.rm = TRUE)

# Code foul: 
z<-( a + b ) ^ 2/d
mean (x ,na.rm=TRUE)
```

. . . 

To make code easier to skim quickly it's alright to add extra space for better alignment. 

```{r}
#| eval: false
flights |> 
  mutate(
    speed      = distance / air_time,
    dep_hour   = dep_time %/% 100,
    dep_minute = dep_time %%  100
  )
```

## Pipes

As you begin to use more functions, sequentially, it can start to get unclear what's happening when, and to what. 

```{r}
#| eval: false
median(sqrt(log(mean(gapminder$pop))))
```

. . . 

With nested functions, like those above, you need to read the order of operations inside out, which is a bit awkward. It becomes even more confusing the more function calls you have, especially when they have multiple arguments each. 

. . . 

**Enter the pipe^[[Ceci n'est pas une pipe.](https://en.wikipedia.org/wiki/The_Treachery_of_Images)]:** `|>`

Pipes read "left to right" which is much more intuitive! 

```{r}
#| eval: false
gapminder$pop |> mean() |> log() |> sqrt() |> median()
```

::: {.incremental}
* The above code takes what's on the left-hand side of `|>` and gives it as the first **unnamed** argument to the first function (`mean()`). 
* The result of that function call is then "piped" to the first **unnamed** argument of the second function (`log()`)...
:::

## Pipes

As you can see, pipes allow us to "chain" many function calls together easily. 

. . . 

The so-called "native pipe" (i.e. built into base `R`) is relatively new. Before this, the pipe was a function from the `magrittr` package that looks like this: `%>%`. 

. . . 

This latter version continues to work and has a different functionality than the new, native pipe. 

. . . 

Most importantly, while both the `magrittr` pipe and the native pipe take the RHS (right-hand side) and "pipe" it to the LHS (left-hand side), they operate differently when it comes to explicitly specifying which argument of the RHS to pipe the LHS into. 

. . . 

```{r}
#| eval: false
# magrittr pipe
a %>% gsub('A', '-', x = .)

# native pipe
a |> gsub('A','-', x = _) # _ is the placeholder for |> 
a |> gsub(pattern = 'A', replacement = '-') # leaving the "piped" argument as the only unnamed argument also works 
a |> (\(.) gsub('A', '-', x = .))() # using an anonymous function call allows you to be explicit while specifying your own placeholder
```

::: aside
You can read more about the differences between `|>` and `%>%` [here](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/#-vs) and anonymous functions [here](http://adv-r.had.co.nz/Functional-programming.html#anonymous-functions). Code above comes from responses to [this stackoverflow post](https://stackoverflow.com/questions/70598384/piping-second-or-higher-argument-in-native-pipe).
:::

## Pipes

Some good syntax practices: 

::: {.incremental}
* You should always put a space before `|>` and it should usually be the last thing on a line.  
* New functions should be on a new line, indented 2 spaces (RStudio will automatically do this for you)
* Named arguments within a function should also get their own line
:::

```{r}
#| eval: false
# code goals
flights |>  
  group_by(tailnum) |> 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# code fouls
flights |>
  group_by(
    tailnum
  ) |> 
  summarize(delay = mean(arr_delay, na.rm = TRUE), n = n())


```

## Selecting the native pipe

The `|>`  is recommended over `%>%` simply because it's always available (`%>%` relied on the `magrittr` package which was a dependency of `tidyverse` packages) and it's much simpler to use. 

. . . 

You'll need to specify to `R` that you want to enable its usage by going to *Tools* > *Global Options* > *Code*. Within the "Editing" Tab there is an option to "Use native pipe operator, `|>`". Check it! <span style="color:#e15759">{{< fa check >}}</span>

![](images/rstudio-pipe-options.png){fig-align="center" width=80%}

## Other Formatting Options

There are some other useful formatting options I'd suggest setting globally and others you can specify to your preferences. 

#### Rainbow Parentheses & HighLight Function Calls

![](images/rainbow_function.png)

## Styling existing code

Imagine you've inherited a bunch of code from someone else and NOTHING is styled in the `tidyverse` way you've become accustomed. Or, you've dabbled in `R` before and you have some old code that is all over the place, with respect to styling. 

. . . 

Thanks to Lorenz Walthert there's a package for that! Using the [`styler` package](https://styler.r-lib.org/index.html) you can automatically apply the [`tidyverse` style guide](https://style.tidyverse.org/) standards to various filetypes (.R, .qmd, .Rmd, etc.) or even entire projects. 

. . . 

Have a style or variation of the `tidyverse` style that you prefer? You can specify that in the package as well. Use the keyboard shortcut *Cmd*/*Ctl* + *Shift* + *P* and search for "styler" to see all the options available.

![](images/rstudio-styler.png){width=80% fig-align="center"}

# Workflow{.section-title background-color="#99a486"}

## .R scripts

We've been working with Quarto documents but you'll sometimes simply want to use an R script, which is basically an entire file that is just a code chunk. 

. . . 

::: {.panel-tabset}
### Why would you prefer an .R file over a .qmd file? 

* You just need to run code, without the need for accompanying text output and plots in the same document. Examples include: 
  * Reading in and cleaning/manipulating your data before analysis
  * Writing functions you'll use throughout your project 
  * Getting descriptive statistics/making descriptive plots of data
  * Running models and generating tables/plots of their results
  
### When might you use a .qmd file? 

* Homework assignments (like for this class) that require you to show code, describe your process for arriving at your solution, and include any results (i.e. tables, statistics, visualizations) 
* Academic articles
* Presentations for class, conferences, talks, etc. 
* Theses/dissertations 
* Interactive visualizations (i.e. widgets)
* Building your own website
:::

## File naming

File names should:

* be machine readable: avoid spaces, symbols, and special characters. Don’t rely on case sensitivity to distinguish files.
* be human readable: use file names to describe what’s in the file.
* play well with default ordering: start file names with numbers so that alphabetical sorting puts them in the order they get used.

## File naming

::: {.panel-tabset}

### Good Example directory
```
01-load-data.R
02-exploratory-analysis.R
03-model-approach-1.R
04-model-approach-2.R
fig-01.png
fig-02.png
report-2022-03-20.qmd
report-2022-04-02.qmd
report-draft-notes.txt
```

<br>

::: {.incremental}
* Numbering scripts makes it clear in which order they should be run. 
* Consistent naming scheme makes it easy to see what things are grouped together and what varies. 
* With many files in one directory you should go a step further and create subfolders for different types of files (i.e. scripts, figures, tables, etc.)
:::

### Bad Example directory
```
alternative model.R
code for exploratory analysis.r
finalreport.qmd
FinalReport.qmd
fig 1.png
Figure_02.png
model_first_try.R
run-first.r
temp.txt
```

<br>

::: {.incremental}
* Ordering of the files is unclear
* Inconsistent naming is confusing (which final report is THE final report?)
* Non-descriptive naming means more work for you in trying to decipher its contents
:::

:::

## Working directory

Your **working directory** is where `R` will look for any files that you ask it to load and where it'll put anything you ask it to save. It is literally just a folder somewhere on your computer or the remote server/cloud you're working within. 

. . . 

You can ask `R` what your current working directory is by running `getwd()` (`get` `w`orking `d`irectory).

. . . 

```{r}
getwd()
```

You can see above that this lecture was created in a lecture-specific folder within a lectures folder, in a directory for this class, which is in a folder called `GitHub` on the Desktop of my laptop. 

. . . 

While you can technically set your working directory using `setwd()` (`set` `w`orking `d`irectory) and giving `R` a filepath, in the name of reproducible research I strongly advise an alternative: **RStudio projects**. 

## Projects

:::: {.columns}

::: {.column width="65%"}
![](images/new-project.png){fig-align="center"}
:::

::: {.column width="35%"}
You can create a project by clicking

* *File* > *New Project...*
* <span>&emsp;&emsp;</span> ![](images/rproject_icon.png){.absolute top=200} in the upper-left corner of RStudio
* the dropdown menu in the upper-right corner of RStudio and selecting *New Project...*

:::
::::


## Projects

A "project" is RStudio's built-in organizational support system which keeps all the files associated with a given project (i.e. data, R scripts, figures, results) together in one directory. 

. . . 

Creating a new project quite basically creates a new folder in a place that you specify. But it also does a few of other extremely useful things: 

::: {.incremental}
* Creates a `.Rproj` file which tracks your command history and all the files in your project folder. 
* Contains all the files needed to reproduce your work 
  * i.e. you can send a project folder to someone and they will be able to run it on their local machine
* Facilitates version control with built-in git/GitHub connection *(more on this later in the course)*
:::

## Getting Help

One of the most difficult things as a beginner in `R` (or any language tbh) is not always knowing what to ask to solve your issue. Being in this class is a great first step! Some other useful tools: 

- **Google** 
  - Adding `R` to your query is basic but useful and often overlooked. Including the package name, if you're using one, is another. Finally, what is it you want to do? For example "R dplyr create new variable based on value of another." 
  - Copy and pasting error messages is also helpful! 
- **StackOverflow**
  - Many of your Google queries will take you here anyways so you might try going directly to the source! Filter by `R` and make sure to include a `reprex` so people can actually understand what your issue is. 
- **Reprex**
  - Short for minimal `repr`oducible `ex`ample this is a version of your code that someone could copy and run on their own machine, making it possible for them to help you troubleshoot your problem. 
  - You want to strip away everything not pertinent to the issue you're having so that it's simple and straightforward. 
  - You can use the [`reprex`](https://reprex.tidyverse.org/) package for assitance with this! 
- **Putting in the work up front**
  - It's cliché but investing in your learning right now will pay off down the road
  - Learning how to do something, why `R` works in a certain way, and developing practices that keep you organized will make you more efficient and help prevent minor and major frustrations


# START OF CHUCK'S SECTION

# Reproducible Research{.section-title background-color="#99a486"}

## Why Reproducibility?

Reproducibility is not *replication*.

* **Replication** is running a new study to show if and how results of a prior study hold.
* **Reproducibility** is about rerunning *the same study* and getting the *same results*.

. . . 

Reproducible studies can still be *wrong*... and in fact reproducibility makes proving a study wrong *much easier*.

. . . 

Reproducibility means:

* Transparent research practices.
* Minimal barriers to verifying your results.

. . . 

*Any study that isn't reproducible can be trusted only on faith.*

## Reproducibility Definitions

Reproducibility comes in three forms (Stodden 2014):

. . . 

::: {.incremental}
1. **Empirical:** Repeatability in data collection.
2. **Statistical:** Verification with alternate methods of inference.
3. **Computational:** Reproducibility in cleaning, organizing, and presenting data and results.
:::

. . . 

R is particularly well suited to enabling **computational reproducibility**^[ Python is equally well suited. Julia is an option as well.].

. . . 

They will not fix flawed research design, nor offer a remedy for improper application of statistical methods.

Those are the difficult, non-automatable things you want skills in.

## Computational Reproducibility

Elements of computational reproducibility:

. . . 

* Shared data
   + Researchers need your original data to verify and replicate your work.
* Shared code
   + Your code must be shared to make decisions transparent.

. . . 

* Documentation
   + The operation of code should be either self-documenting or have written descriptions to make its use clear.

. . . 

* **Version Control**
   + Documents the research process.
   + Prevents losing work and facilitates sharing.

## Levels of Reproducibility

For academic papers, degrees of reproducibility vary:

::: {.incremental}
0. "Read the article"
1. Shared data with documentation
2. Shared data and all code
3. **Interactive document**
4. **Research compendium**
5. Docker compendium: Self-contained ecosystem
:::

## Interactive Documents

**Interactive documents** — like Quarto docs — combine code and text together into a self-contained document.

* Load and process data
* Run models
* Generate tables and plots in-line with text
* In-text values automatically filled in

. . . 

Interactive documents allow a reader to examine your computational methods within the document itself; in effect, they are self-documenting.

. . . 

By re-running the code, they reproduce your results on demand.

. . . 

Common Platforms:

 * **R:** Quarto
 * **Python:** Jupyter Notebooks

## Research Compendia

A **research compendium** is a portable, reproducible distribution of an article or other project.

. . . 

Research compendia feature:

* An interactive document as the foundation

* Files organized in a recognizable structure (e.g. an R package)

* Clear separation of data, method, and output. *Data are read only*.

* A well-documented or even *preserved* computational environment (e.g. Docker)

. . . 

`rrtools` by UW's [Ben Markwick](https://github.com/benmarwick) provides a simplified workflow to accomplish this in R.

## Bookdown

[`bookdown`](https://bookdown.org/yihui/bookdown/) — which is integrated into `rrtools` — can generate documents in the proper format for articles, theses, books, or dissertations.

. . . 

`bookdown` provides an accessible alternative to writing $\LaTeX$ for typesetting and reference management.

. . . 

You can integrate citations and automate reference page generation using bibtex files (such as produced by Zotero).

. . . 

`bookdown` supports `.html` output for ease and speed and also renders `.pdf` files through $\LaTeX$ for publication-ready documents.

. . . 

For University of Washington theses and dissertations, consider Ben Marwick's [`huskydown` package](https://github.com/benmarwick/huskydown) which uses Markdown but renders via a UW approved $\LaTeX$ template.

# Best Practices{.section-title background-color="#99a486"}

## Organization and Portability

## Organization Systems

Organizing research projects is something you either do accidentally — and badly — or purposefully with some upfront labor.

. . . 

Uniform organization makes switching between or revisiting projects easier.

. . . 

I suggest something like the following:

:::: {.columns}
::: {.column width="50%"}
```
project/
   readme.md
   data/
     derived/
       processed_data.RData
     raw/
       core_data.csv
   docs/
     paper.Rmd
   syntax/
     functions.R
     models.R
```
:::
::: {.column width="50%"}
1. There is a clear hierarchy
   * Written content is in `docs`
   * Code is in `syntax`
   * Data is in `data`
2. Naming is uniform
   * All lower case
   * Words separated by underscores
3. Names are self-descriptive
:::
::::

## Workflow versus Project

To summarize Jenny Bryan, [one should separate workflow from projects.](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/)

<br>

. . . 

:::: {.columns}
::: {.column width="50%"}

### Workflow

* The software you use to write your code (e.g. RStudio)

* The location you store a project

* The specific computer you use

* The code you ran earlier or typed into your console

:::
::: {.column width="50%"}

### Project

* The raw data

* The code that operates on your raw data

* The packages you use

* The output files or documents

:::
::::

. . . 

<br>

Projects *should not modify anything outside of the project* nor need to be modified by someone else (or future you) to run.

**Projects *should be independent of your workflow*.**

## Portability

For research to be reproducible, it must also be *portable*. Portable software operates *independently of workflow* such as fixed file locations.

::: {.panel-tabset}

### **Do Not:**

* Use `setwd()` in scripts or .Rmd files.
* Use *absolute paths* except for *fixed, immovable sources* (secure data).
  + `read_csv("C:/my_project/data/my_data.csv")`
* Use `install.packages()` in script or .Rmd files.
* Use `rm(list=ls())` anywhere but your console.

### **Do:**

:::: {.columns}

::: {.column width="50%"}
* Use RStudio projects (or the [`here` package](https://github.com/jennybc/here_here)) to set directories.
* Use *relative paths* to load and save files:
  + `read_csv("./data/my_data.csv")`
* Load all required packages using `library()`.
* Clear your workspace when closing RStudio.
  + Set *Tools > Global Options... > Save workspace...* to **Never**
:::

::: {.column width="50%"}

![](images/clean-slate.png){.absolute right=10 bottom=10 height=75%}

:::

::::



:::

## Divide and Conquer

Often you do not want to include all code for a project in one `.qmd` file:

   * The code takes too long to knit.
   * The file is so long it is difficult to read.

. . . 

There are two ways to deal with this:

1. Use separate `.R` scripts or `.qmd` files which save results from complicated parts of a project, then load these results in the main `.qmd` file.

   + This is good for loading and cleaning large data.
   + Also for running slow models.

. . . 

2. Use `source()` to run external `.R` scripts when the `.qmd` renders

   + This can be used to run large files that aren't impractically slow.
   + Also good for loading project-specific functions.

## The Way of Many Files

I find it beneficial to break projects into *many* files:

* Scripts with specialized functions.
* Scripts to load and clean each set of variables.
* Scripts to run each set of models and make tables and plots.
* A main .qmd that runs some or all of these to reproduce the entire project.

. . . 

Splitting up a project carries benefits:

* Once a portion of the project is done and in its own file, *it is out of your way.*
* If you need to make changes, you don't need to search through huge files.
* Entire sections of the project can be added or removed quickly (e.g. converted to an appendix of an article)
* **It is the only way to build a proper *pipeline* for a project. **

## Pipelines

Professional researchers and teams design projects as a **pipeline**.

. . . 

A **pipeline** is a series of consecutive processing elements (scripts and functions in R).

. . . 

Each stage of a pipeline...

1. Has clearly defined inputs and outputs
2. Does not modify its inputs.
3. Produces the exact same output every time it is re-run.

. . . 

This means...

1. When you modify one stage, you only need to rerun *subsequent stages*.
2. Different people can work on each stage.
3. Problems are isolated within stages.
4. You can depict your project as a *directed graph* of **dependencies**.

## Example Pipeline

Every stage (oval) has an unambiguous input and output. Everything that precedes a given stage is a **dependency** — something required to run it.

![](images/pipeline.svg)

::: aside
Note: [`targets` is a great package for managing R research pipelines.](https://docs.ropensci.org/targets/)
:::

# Tools (*some opinionated advice*) {.section-title background-color="#99a486"}

## On Formats

Avoid "closed" or commercial software and file formats except where absolutely necessary.

. . . 

Use open source software and file formats.

. . . 

* It is always better for *science*:

   + People should be able to explore your research without buying commercial software.
   + You do not want your research to be inaccessible when software is updated.

. . . 

* It is often just *better*.

   + It is usually updated more quickly
   + It tends to be more secure
   + It is rarely abandoned

. . . 

**The ideal:** Use software that reads and writes *raw text*.

## Text

Writing and formatting documents are two completely separate jobs.

* Write first
* Format later
* [Markdown](https://en.wikipedia.org/wiki/Markdown) was made for this

. . . 

Word processors — like Microsoft Word — try to do both at the same time, usually badly.

They waste time by leading you to format instead of writing.

. . . 

Find a good modular text editor and learn to use it:

* [Atom](https://atom.io/)
* [Sublime](https://www.sublimetext.com/) (Commercial)
* Emacs
* Vim

# Version Control{.section-title background-color="#99a486"}

## Version Control

Version control originates in collaborative software development.

**The Idea:** All changes ever made to a piece of software are documented, saved automatically, and revertible.

. . . 

Version control allows all decisions ever made in a research project to be documented automatically.

. . . 

Version control can:

1. Protect your work from destructive changes
2. Simplify collaboration by merging changes
3. Document design decisions
4. Make your research process transparent

## Git and GitHub

[`git`](https://en.wikipedia.org/wiki/Git) is the dominant platform for version control, and [GitHub](https://github.com/) is a free (and now Microsoft owned) platform for hosting **repositories**.

. . . 

**Repositories** are folders on your computer where all changes are tracked by Git.

. . . 

Once satisfied with changes, you "commit" them then "push" them to a remote repository that stores your project.

. . . 

Others can copy your project ("pull"), and if you permit, make suggestions for changes.

. . . 

Constantly committing and pulling changes automatically generates a running "history" that documents the evolution of a project.

. . . 

`git` is integrated into RStudio under the *Tools* menu. [It requires some setup.](http://happygitwithr.com/)^[You can also use the [GitHub desktop application](https://desktop.github.com/).]


## GitHub as a CV

Beyond archiving projects and allowing sharing, GitHub also serves as a sort of curriculum vitae for the programmer.

. . . 

By allowing others to view your projects, you can display competence in programming and research.

. . . 

If you are planning on working in the private sector, an active GitHub profile will give you a leg up on the competition.

. . . 

If you are aiming for academia, a GitHub account signals technical competence and an interest in research transparency.

## Due dates

## Due dates

```{r}
#| echo: false
#| message: false
#| warning: false

# reading in base due date schedule
source("../due_dates_schedule.R")

make_due_date_table(3)
```