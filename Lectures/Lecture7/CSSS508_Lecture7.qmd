---
execute: 
  echo: true
  message: false
  warning: false
  fig-format: "svg"
format: 
  revealjs:
    highlight-style:  a11y-dark
    reference-location: margin
    theme: lecture_styles.scss
    slide-number: true
    code-link: true
    chalkboard: true
    incremental: false 
    smaller: true
    preview-links: true
    code-line-numbers: true
    history: false
    progress: true
    link-external-icon: true
    code-annotations: hover
    pointer:
      color: "#b18eb1"
revealjs-plugins:
  - pointer
---

```{r}
#| echo: false
#| cache: false
require(downlit)
require(xml2)
require(tidyverse)
```

## {#title-slide data-menu-title="Working with Text Data" background="#1e4655" background-image="../../images/csss-logo.png" background-position="center top 5%" background-size="50%"}

```{r}
#| echo: false
#| cache: false
require(downlit)
require(xml2)
require(tidyverse)

knitr::opts_chunk$set(comment = ">")
```

[Working with Text Data]{.custom-title}

[CS&SS 508 â€¢ Lecture 7]{.custom-subtitle}

[14 November 2023]{.custom-subtitle2}

[Victoria Sass]{.custom-subtitle3}

# Roadmap{.section-title background-color="#99a486"}

---

:::: {.columns}

::: {.column width="50%"}

<br>

### Last time, we learned:

* Types of Data
  * Numbers
  * Missing Values
* Data Structures
  * Vectors
  * Matrices
  * Lists
:::

::: {.column width="50%"}

<br> 

::: {.fragment}
### Today, we will cover:

* Types of Data
  * Strings
* String Manipulation
* Regular Expressions

:::

:::

::::


# Strings{.section-title background-color="#99a486"}

# {data-menu-title="`stringr``" background-image="images/stringr.png" background-size="contain" background-position="center" .section-title background-color="#1e4655"}

## Basics of Strings

::: {.incremental}
* A general programming term for a unit of character data is a **string**
  + Strings are a *sequence of characters*
  + In R, "strings" and "character data" are mostly interchangeable.
  + Some languages have more precise distinctions, but we won't worry about that here!
:::

::: {.incremental}
* We can create strings by surrounding text, numbers, spaces, or symbols with quotes!
  + Examples: `"Hello! My name is Vic"` or `"%*$#01234"`
* You can create a string using either single quotes (`' '`) or double quotes (`" "`)
  * In the interests of consistency, the tidyverse style guide recommends using `" "`, unless the string contains multiple `" "`
:::

## Escaping with Strings

We use a lot of different symbols in our code that we might actually want to represent *within* a string itself. To do that, we need to escape that particular character. We can do that using `\`.

. . .

For instance, if we want to include a literal single or double quote in our string, we'd escape it by writing:

```{r}
#| eval: false
"\'" # <1>
'\"' # <2>
```
1. Double quote.
2. Single quote.

. . . 

Similarly, if we want to represent a `\` we'll need to escape it as well...

```{r}
#| eval: false
"\\" # <3>
```
3. Backslash.

. . . 

**Note**: When you print these objects you'll see the escape characters. To actually view the string's contents ( and not the syntax needed to construct it), use `str_view()`. 

. . . 

```{r}
str_view(c('\"', "\"", "\\")) # <4>
```
4. All `stringr` functions begin with the prefix `str_` which is useful due to R Studio's auto-complete feature.

## Other Special Characters

There are other things you may want to represent inside a character string, such as a new line, or a tab space. 

. . . 

```{r} 
#| output-location: fragment
str_view("Sometimes you need\nto create another line.") # <5>
str_view("\tOther times you just need to indent somewhere.") # <6>
```
5. Use `\n` to create a new line. Helpful when plotting if you have variable names or values that are wordy!
6. Use `\t` to add a tab. `str_view` will highlight tabs in blue in your console to make it stand out from other random whitespace. 

. . . 

Additionally, you can represent [Unicode](https://en.wikipedia.org/wiki/List_of_Unicode_characters) characters which will be written with the `\u` or `\U` escape. 

```{r}
str_view(c("\U1F00F", "\u2866", "\U1F192"))
```

## Data: King County Restaurant Inspections!

Today we'll study real data on **food safety inspections in King County**, collected from [data.kingcounty.gov](https://data.kingcounty.gov/Health/Food-Establishment-Inspection-Data/f29f-zza5).

```{r reading_data}
#| eval: false
#| echo: false
restaurants <- read_csv("data/Food_Establishment_Inspection_Data_20231102.csv")
save(restaurants, file = "Lectures/Lecture7/data/restaurants.Rdata")
```


Note these data are *fairly large* in their native `.csv` format. The following code can be used to download the data directly from my `Github` page as a smaller, `.Rdata` object:

```{r}
#| cache: true
load(url("https://github.com/vsass/CSSS508/raw/main/Lectures/Lecture7/data/restaurants.Rdata"))
```

## Quick Examination of the Data

```{r}
glimpse(restaurants)
```

<br>

. . . 

<h4 align="center">Good Questions to Ask</h4>

:::: {.columns}

::: {.column width="50%"}
::: {.incremental }
* What does each row represent?
* Is the data in long or wide format?
:::
:::

::: {.column width="50%"}
::: {.incremental}
* What are the key variables?
* How are the data stored? (*data type*)
:::
:::

::::

## Creating Strings
You can create strings based on the value of other strings with `str_c()` (`str`ing `c`ombine), which takes any number of vectors and returns a character vector. 

```{r}
#| output-location: fragment
str_c(c("CSSS", "STAT", "SOC"), 508) # <7>
str_c(c("CSSS", "STAT", "SOC"), 508, sep = " ") # <8>
str_c(c("CSSS", "STAT", "SOC"), 508, sep = " ", collapse = ", ") # <9>
```
7. By default, `str_c` doesn't put a space between the vectors it is combining.
8. You can add a specific separator, including a space, using the `sep` argument. 
9. If you want to combine the output into a single string, use `collapse`. 

## Example with Restaurant Data

You can create strings based on the value of other strings with `str_c()` (`str`ing `c`ombine), which takes any number of vectors and returns a character vector. 

. . . 

```{r}
#| output-location: fragment
restaurants |> 
  select(Name, Address, City) |> 
  distinct() |> 
  mutate(Sentence = str_c(Name, " is located at ", Address, " in ", City, ".")) # <10>
```
10. Notice there are spaces at the beginning and end of the fixed character strings. This is because if we used the `sep` argument here it would add a space before the period at the end of the sentence. So instead, we can add them directly where we want them. 

## Creating Strings

As we saw in the previous example, when you're mixing many fixed and variable strings with `str_c()` things can get overwhelmed by quotation marks pretty easily. An alternative with simpler syntax is `str_glue()` in which anything inside `{}` will be evaluated like it's outside the quotes. 

```{r}
#| output-location: fragment
restaurants |> 
  select(Name, Address, City) |> 
  distinct() |> 
  mutate(Sentence = str_glue("{Name} is located at {Address} in {City}."))
```

## Creating Strings

If you want to create a summary of certain character strings you can use `str_flatten()` which takes a character vector and combines each element of the vector into a single string. 

. . . 

```{r}
#| output-location: fragment
restaurants |> 
  select(Name, `Inspection Score`) |> # <11>
  summarize(inspection_scores = str_flatten(`Inspection Score`, ", "), 
            .by = Name)
```
11. Notice that when a variable has spaces in it's name (rather than being separated with an underscore in snake_case, for instance) you need to put backticks around it so `R` knows it is a singular object name. 


## Base `R` Equivalents

:::: {.columns}

::: {.column width="50%"}
#### Base `R`
[paste0(x, sep, collapse)]{.custom-code}


:::

::: {.column width="50%"}
#### `stringr`
[str_c(x, sep, collapse)]{.custom-code}

:::

::::










