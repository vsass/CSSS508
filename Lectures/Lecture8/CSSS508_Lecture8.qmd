---
execute: 
  echo: true
  message: false
  warning: false
  fig-format: "svg"
format: 
  revealjs:
    theme: lecture_styles.scss
    highlight-style:  a11y-dark
    reference-location: margin
    slide-number: true
    code-link: true
    chalkboard: true
    incremental: false 
    smaller: true
    preview-links: true
    code-line-numbers: true
    history: false
    progress: true
    link-external-icon: true
    code-annotations: hover
    pointer:
      color: "#b18eb1"
revealjs-plugins:
  - pointer
---

```{r}
#| echo: false
#| cache: false
require(downlit)
require(xml2)
require(tidyverse)

knitr::opts_chunk$set(comment = ">")
```

##  {#title-slide data-menu-title="Writing Functions" background="#1e4655" background-image="../../images/csss-logo.png" background-position="center top 5%" background-size="50%"}

[Writing Functions]{.custom-title}

[CS&SS 508 â€¢ Lecture 8]{.custom-subtitle}

[21 November 2023]{.custom-subtitle2}

[Victoria Sass]{.custom-subtitle3}

# Roadmap {.section-title background-color="#99a486"}

------------------------------------------------------------------------

::: columns
::: {.column width="50%"}
<br>

### Last time, we learned:

-   Types of Data
    -   Strings
-   Pattern Matching & Regular Expressions
:::

::: {.column width="50%"}
<br>

::: fragment
### Today, we will cover:

- Function Basics
- Types of Functions
  - Vector Functions
  - Dataframe Functions
  - Plot Functions

:::
:::
:::

# Function Basics {.section-title background-color="#99a486"}

## Why Functions?

<br>

R (as well as mathematics in general) is full of functions!

. . .

<br>

We use functions to:

-   Compute summary statistics (`mean()`, `sd()`, `min()`)
-   Fit models to data (`lm(Fertility ~ Agriculture, data = swiss)`)
-   Read in data (`read_csv()`)
-   Create visualizations (`ggplot()`)
-   And a lot more!!

## Examples of Existing Functions

::: incremental
-   `mean()`:
    -   Input: a vector
    -   Output: a single number
-   `dplyr::filter()`:
    -   Input: a data frame, logical conditions
    -   Output: a data frame with rows removed using those conditions
-   `readr::read_csv()`:
    -   Input: a file path, optionally variable names or types
    -   Output: a data frame containing info read in from file
:::

. . .

Each function requires **inputs**, and returns **outputs**

## Why Write Your Own Functions?

::: {.incremental}
* Functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting
* As requirements change, you only need to update code in one place, instead of many.
* You eliminate the chance of making incidental mistakes compared to when you copy and paste (i.e. updating a variable name in one place, but not in another).
* It makes it easier to reuse work from project-to-project, increasing your productivity over time.
* If well named, your function can make your overall code easier to understand.
:::

## Plan your Function before Writing

<br>

Before you can write effective code, you need to know *exactly* what you want:

::: incremental
-   **Goal:** Do I want a single value? vector? one observation per person? per year?
-   **Current State:** What do I currently have? data frame, vector? long or wide format?
-   **Translate:** How can I take what I have and turn it into my goal?
    -   Sketch out the steps!
    -   Break it down into little operations
:::

. . .

**As we become more advanced coders, this concept is key!!**

**Remember:** *When you're stuck, try searching your problem on Google!!*

## Simple, Motivating Example 

:::: {.columns}

::: {.column width="62%"}
```{r}
#| eval: false
df <- tibble(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5),
  d = rnorm(5)
  )
df

df |> mutate(
  a = (a - min(a, na.rm = TRUE)) / 
    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / 
    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / 
    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / 
    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))
  )
```

::: {.incremental .fragment fragment-index=3}
* What do you think this code does? 
* Are there any typos? 
* Could we write this more efficiently as a function? 
:::

:::

::: {.column width="38%"}
::: {.fragment fragment-index=1}
```{r}
#| echo: false
df <- tibble(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5),
  d = rnorm(5)
  )
df
```
:::

::: {.fragment fragment-index=2}
```{r}
#| echo: false
df |> mutate(
  a = (a - min(a, na.rm = TRUE)) / 
    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / 
    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / 
    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / 
    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))
  )
```
:::
:::

::::



## Writing a Function

To write a function you need to first analyse your repeated code to figure what parts are constant and what parts vary.

. . . 

<br>

Let's look at the contents of the mutate from the last slide again. 

. . . 

```{r}
#| eval: false
(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))
(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))
(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))
(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  
```

. . . 

There's quite a bit of repetition here and only a few elements that change.

. . . 

<br>

We can see how concise our code can be if we replace the varying part with ðŸŸª:

```{r}
#| eval: false
(ðŸŸª - min(ðŸŸª, na.rm = TRUE)) / (max(ðŸŸª, na.rm = TRUE) - min(ðŸŸª, na.rm = TRUE))
```

## Anatomy of a Function

To turn our code into a function we need three things:

::: incremental
-   **Name**: What you call the function so you can use it later. The more explanatory this is the easier your code will be to understand.
-   **Argument(s)** (aka input(s), parameter(s)): What the user passes to the function that affects how it works. This is what varies across calls.
-   **Body**: The code thatâ€™s repeated across all the calls. 
:::

. . . 

**Function Template**

```{r}
#| eval: false
NAME <- function(ARGUMENT1, ARGUMENT2 = DEFAULT){ # <1> 
  BODY 
}
```
1. In this example, `ARGUMENT1`, `ARGUMENT2` values won't exist outside of the function. `ARGUMENT2` is an optional argument as it's been given a default value to use if the user does not specify one. 

. . . 

For our current example, this would be: 

```{r}
rescale01 <- function(x) { # <2>
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}
```
2. You can name the placeholder value(s) whatever you want but `x` is the conventional name for a numeric vector so we'll use `x` here. 

## Testing Your Function

It's good practice to test a few simple inputs to make sure your function works as expected.

. . . 

```{r}
rescale01(c(-10, 0, 10))
rescale01(c(1, 2, 3, NA, 5))
```

. . . 

<br> 

Now we can rewrite our original code in a much simpler way!

. . . 

```{r}
df |> mutate(a = rescale01(a),
             b = rescale01(b),
             c = rescale01(c),
             d = rescale01(d))
```

## Improving Your Function

Writing a function is often an iterative process. You'll write the core of the function and then notice that it needs to include some additional syntax to handle a specific use-case or ways it can generally be made more efficient. 

:::: {.columns}

::: {.column width="42%"}
::: {.fragment}

<br>

For instance, you might observe that our function does some unnecessary computational repetition by evaluating `min()` twice and `max()` once when both can be computed once with `range()`. 
:::

::: {.fragment}

<br>

```{r}
#| code-line-numbers: false
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```
:::
:::

::: {.column width="58%"}
::: {.fragment}

<br>

Or you might find out through trial and error that our function doesn't handle infinite values well. 

```{r}
#| code-line-numbers: false
x <- c(1:10, Inf)
rescale01(x)
```
:::
::: {.fragment}
Updating it to exclude infinite values makes it more general as it accounts for more use cases. 

```{r}
#| code-line-numbers: false
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

:::

:::

::::

# Vector Functions {.section-title background-color="#99a486"}

## What are Vector Functions?

The function we just created is a vector function!

. . . 

Vector functions are simply functions that take one or more vectors as input and return a vector as output.

. . . 

There are two types of vector functions: mutate functions and summary functions. 

. . . 

<br>

::: {.fragment}
#### Mutate Functions

* Return an output the same length as the input
* Therefore, these functions work well within `mutate()` and `filter()`
:::

<br>

::: {.fragment}
#### Summary Functions

* Returns a single value 
* Therefore well suited for use in `summarize()`
:::

## Examples of Mutate Functions

. . . 

```{r}
z_score <- function(x) { 
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE) # <1>
} 

ages <- c(25, 82, 73, 44, 5)
z_score(ages)
```
1. Rescales a vector to have a mean of zero and a standard deviation of one.

. . . 

```{r}
clamp <- function(x, min, max) { 
  case_when( # <2>
    x < min ~ min, # <2>
    x > max ~ max, # <2>
    .default = x # <2>
  ) 
} 

clamp(1:10, min = 3, max = 7)
```
2. Ensures all values of a vector lie in between a minimum or a maximum. 

. . . 

```{r}
first_upper <- function(x) { 
  str_sub(x, 1, 1) <- str_to_upper(str_sub(x, 1, 1)) # <3>
  x # <3>
} 

first_upper("hi there, how's your day going?")
```
3. Make the first character upper case. 

## Examples of Summarize Functions

. . . 

```{r}
cv <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm) # <4>
}

cv(runif(100, min = 0, max = 50))
```
4. Calculation for the coefficient of variation, which divides the standard deviation by the mean. 

. . . 

```{r}
n_missing <- function(x) {
  sum(is.na(x)) # <5>
} 
```
5. Calculates the number of missing values. [Source](https://twitter.com/gbganalyst/status/1571619641390252033)

. . . 

```{r}
mape <- function(actual, predicted) {
  sum(abs((actual - predicted) / actual)) / length(actual) # <6>
}
```
6. Calculates the mean absolute percentage error to help you compare model predictions with actual values. 


# Homework{.section-title background-color="#1e4655"}

## {data-menu-title="Homework 8" background-iframe="https://vsass.github.io/CSSS508/Homework/HW8/homework8.html" background-interactive=TRUE}
