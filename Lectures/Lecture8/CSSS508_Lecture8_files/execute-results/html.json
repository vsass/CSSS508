{
  "hash": "62ec3cbc30becf467590ce0b7e9851cd",
  "result": {
    "markdown": "---\ntitle: \"CSSS 508 • Lecture 8\"\nsubtitle: \"Working with Text Data\"\nauthor: \"Victoria Sass\"\ndate: \"November 14, 2023\"\ndate-format: long\nhighlight-style:  vim-dark #, oblivion, radical, vim-dark, espresso, zenburn, kate, monochrome, breezedark, haddock\nfootnotes-hover: true\nreference-location: margin\nexecute: \n  echo: true\n  message: false\n  warning: false\n  fig-format: \"svg\"\nformat: \n  revealjs:\n    theme: lecture_styles.scss\n    slide-number: true\n    code-link: true\n    chalkboard: true\n    incremental: false \n    smaller: true\n    preview-links: true\n    code-line-numbers: false\n    #logo: \"../../images/csss-white.png\" # need to add css for size <https://stackoverflow.com/questions/74083521/how-to-increase-size-logo-in-quarto-reveal-js-presentation>\n---\n\n::: {.cell}\n\n:::\n\n\n# Roadmap\n\n---\n\n<br>\n\nLast time, we learned about,\n\n* Aside: Visualizing the Goal\n* Building blocks of functions\n* Simple functions\n* Using functions with `apply()`\n\n. . . \n\nToday, we will cover,\n\n* Basics of Strings\n* Strings in Base R\n* Strings in `stringr` (tidyverse)\n\n# Basics of Strings\n\n## Basics of Strings\n\n::: {.incremental}\n* A general programming term for a unit of character data is a **string**\n  + Strings are a *sequence of characters*\n  + In R, \"strings\" and \"character data\" are mostly interchangeable.\n  + Some languages have more precise distinctions, but we won't worry about that here!\n:::\n\n::: {.incremental}\n* We can create strings by surrounding text, numbers, spaces, or symbols with quotes!\n  + Examples: `\"Hello! My name is Vic\"` or `\"%*$#01234\"`\n:::\n\n## Basics of Strings \n\nR can treat strings in funny ways!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"01\" == \"1\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n\"01\" == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n\"1\" == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n. . . \n\n*Reminder:* We can check **data types** using the `class()` function!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(class(\"1\"), class(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\" \"numeric\"  \n```\n:::\n:::\n\n\n# Strings in Base R\n\n* `nchar()`\n* `substr()`\n* `paste()`\n\n## Data: King County Restaurant Inspections!\n\nToday we'll study real data on **food safety inspections in King County**, collected from [data.kingcounty.gov](https://data.kingcounty.gov/Health/Food-Establishment-Inspection-Data/f29f-zza5).\n\nNote these data are *fairly large*. The following code can be used to download the data directly from my Github page:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurants <- read_csv(file = \"https://raw.githubusercontent.com/vsass/CSSS508/main/Lectures/Lecture8/data/restaurants.csv\")\n```\n:::\n\n\n## Quick Examination of the Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(restaurants)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Name\"                       \"Program Identifier\"        \n [3] \"Inspection Date\"            \"Description\"               \n [5] \"Address\"                    \"City\"                      \n [7] \"Zip Code\"                   \"Phone\"                     \n [9] \"Longitude\"                  \"Latitude\"                  \n[11] \"Inspection Business Name\"   \"Inspection Type\"           \n[13] \"Inspection Score\"           \"Inspection Result\"         \n[15] \"Inspection Closed Business\" \"Violation Type\"            \n[17] \"Violation Description\"      \"Violation Points\"          \n[19] \"Business_ID\"                \"Inspection_Serial_Num\"     \n[21] \"Violation_Record_ID\"        \"Grade\"                     \n```\n:::\n\n```{.r .cell-code}\ndim(restaurants)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 255270     22\n```\n:::\n:::\n\n\n## Quick Examination of the Data\n\n**Good Questions to Ask:**\n\n* What does each row represent?\n* Is the data in long or wide format?\n* What are the key variables?\n* How are the data stored? (*data type*)\n\n## `nchar()`\n\nThe `nchar()` function calculates the *number of characters* in a given string. \n\n* `length()` doesn't work with strings!!\n  * Why not?\n\n. . . \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(\"Victoria Sass\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n\n```{.r .cell-code}\nlength(\"Victoria Sass\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n. . . \n\nIn our `restaurants` data, let's see how many characters are in each zip code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength_zip <- nchar(restaurants$`Zip Code`) # notice when a variable name has spaces we need to contain it within backticks so R knows it is a singular entity\ntable(length_zip)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlength_zip\n     4      5      6 \n    15 255248      1 \n```\n:::\n:::\n\n\n. . . \n\n## `substr()`\n\nThe `substr()` function allows us to extract characters from a string.\n\n. . . \n\nFor example, we can extract the third through fifth elements of a string as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubstr(\"98126\", 3, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"126\"\n```\n:::\n:::\n\n\n## `substr()`\n\nLet's extract the first five characters from each zip code in the restaurants data, and add it to our dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nrestaurants$ZIP_5 <- substr(restaurants$`Zip Code`, 1, 5) \nrestaurants %>% \n  distinct(ZIP_5) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  ZIP_5\n  <chr>\n1 98105\n2 98103\n3 98104\n4 98109\n5 98101\n6 98052\n```\n:::\n:::\n\n\n## `paste()`\n\nWe combine strings together using `paste()`. By default, it puts a space between different strings.\n\n. . . \n\nFor example, we can combine `\"Victoria\"` and `\"Sass\"` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"Victoria\", \"Sass\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Victoria Sass\"\n```\n:::\n:::\n\n\n## More complex `paste()` commands\n\nThere are two additional common arguments to use with `paste()`:\n\n1. `sep =` controls what separates vectors, entry-wise\n1. `collapse =` controls if/how multiple outputs are collapsed into a single string.\n\n. . . \n\nExamples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"CSSS\", \"508\", sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CSSS_508\"\n```\n:::\n\n```{.r .cell-code}\npaste(c(\"CSSS\", \"STAT\"), \"508\", sep = \"_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CSSS_508\" \"STAT_508\"\n```\n:::\n\n```{.r .cell-code}\npaste(c(\"CSSS\", \"STAT\"), \"508\", sep = \"_\", collapse = \" , \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CSSS_508 , STAT_508\"\n```\n:::\n:::\n\n\n*When do we get one string as output vs. two?*\n\n## `paste()`\n\nLet's use `paste()` to create complete mailing addresses for each restaurant:\n\n. . . \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurants$mailing_address <- paste(restaurants$Address, \", \", restaurants$City, \n                                     \", WA \", restaurants$ZIP_5, sep = \"\")\nrestaurants %>% \n  distinct(mailing_address) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 1\n  mailing_address                                  \n  <chr>                                            \n1 2746 NE 45TH ST, SEATTLE, WA 98105               \n2 1906 N 34TH ST, SEATTLE, WA 98103                \n3 122 2ND AVE S, SEATTLE, WA 98104                 \n4 1001 FAIRVIEW AVE N Unit 1700A, SEATTLE, WA 98109\n5 1225 1ST AVE, SEATTLE, WA 98101                  \n6 15364 NE 96TH PL, REDMOND, WA 98052              \n```\n:::\n:::\n\n\n# Strings in `stringr`\n\n* `str_length()`\n* `str_sub()`\n* `str_c()`\n* `str_to_upper()`, `str_to_lower()`, and `str_to_title()`\n* `str_trim()`\n* `str_detect()`\n* `str_replace()`\n\n## `stringr`\n\n`stringr` is yet another R package from the Tidyverse (like `ggplot2`, `dplyr`, `tidyr`, `lubridate`, `readr`).\n\n. . . \n\nIt provides TONS of functions for working with strings:\n\n* Some are equivalent/better versions of Base R functions\n* Some can do *fancier* tricks with strings\n  \n. . . \n\n*Most* `stringr` functions begin with \"`str_`\" to make RStudio auto-complete more useful.\n\n. . . \n\nWe'll cover the basics today, but know there's much more out there!\n    \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\n## Equivalencies: `str_length()`\n\n`str_length()` is equivalent to `nchar()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar(\"weasels\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nstr_length(\"weasels\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\n. . . \n\n## Equivalencies: `str_sub()`\n\n`str_sub()` is like `substr()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(\"Washington\", 2, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ash\"\n```\n:::\n:::\n\n\n. . . \n\n`str_sub()` also lets you put in negative values to count backwards from the end (-1 is the end, -3 is third from end):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(\"Washington\", 4, -3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hingt\"\n```\n:::\n:::\n\n\n## Equivalencies: `str_c()`\n\n`str_c()` (\"string combine\") is just like `paste()` but where the default is `sep = \"\"` (no space!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(c(\"CSSS\",\"STAT\"), 508)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CSSS508\" \"STAT508\"\n```\n:::\n\n```{.r .cell-code}\nstr_c(c(\"CSSS\",\"STAT\"), 508, sep = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CSSS 508\" \"STAT 508\"\n```\n:::\n\n```{.r .cell-code}\nstr_c(c(\"CSSS\",\"STAT\"), 508, sep = \" \", collapse = \", \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CSSS 508, STAT 508\"\n```\n:::\n:::\n\n\n## Changing Cases\n\n`str_to_upper()`, `str_to_lower()`, `str_to_title()` convert cases, which is often a good idea to do before searching for values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_cities <- unique(restaurants$City)\nunique_cities %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SEATTLE\" \"REDMOND\" \"KENT\"    \"KENMORE\" \"Seattle\" \"RENTON\" \n```\n:::\n\n```{.r .cell-code}\nstr_to_upper(unique_cities) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SEATTLE\" \"REDMOND\" \"KENT\"    \"KENMORE\" \"SEATTLE\" \"RENTON\" \n```\n:::\n\n```{.r .cell-code}\nstr_to_lower(unique_cities) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"seattle\" \"redmond\" \"kent\"    \"kenmore\" \"seattle\" \"renton\" \n```\n:::\n\n```{.r .cell-code}\nstr_to_title(unique_cities) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Seattle\" \"Redmond\" \"Kent\"    \"Kenmore\" \"Seattle\" \"Renton\" \n```\n:::\n:::\n\n\n## Whitespace: `str_trim()`\n\nExtra leading or trailing whitespace is common in text data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_names <- unique(restaurants$Name)\nunique_names %>% \n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#807 TUTTA BELLA\" \"+MAS CAFE\"        \"?al?al Cafe\"     \n```\n:::\n:::\n\n\nWe can remove the whitespace using `str_trim()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_trim(unique_names) %>% \n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#807 TUTTA BELLA\" \"+MAS CAFE\"        \"?al?al Cafe\"     \n```\n:::\n:::\n\n\n## Patterns!\n\nIt's common to want to see if a string satisfies a certain *pattern*.\n\n. . . \n\nWe did this with numeric values earlier in this course!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% \n  filter(speed < 5 | speed > 24)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  speed dist\n1     4    2\n2     4   10\n3    25   85\n```\n:::\n\n```{.r .cell-code}\ncars %>% \n  filter(dist > 2 & dist <= 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  speed dist\n1     4   10\n2     7    4\n3     9   10\n```\n:::\n:::\n\n\n## Patterns: `str_detect()`\n\nWe can do similar pattern-checking using `str_detect()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(string, pattern)\n```\n:::\n\n\n* `string` is the character string (or vector of strings) we want to examine\n* `pattern` is the pattern that we're checking for inside `string`\n* Output: TRUE/FALSE vector indicating if pattern was found\n\n. . . \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(string = c(\"Hello\", \"my middle name\", \"is Anne\"),\n           pattern = \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nstr_detect(string = c(\"Hello\", \"my middle name\", \"is Anne\"),\n           pattern = \"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nResults are case-sensitive!!\n\n## Patterns: `str_detect()`\n\nLet's see which phone numbers are in the 206 area code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_phones <- unique(restaurants$Phone)\nunique_phones %>% tail(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"(206) 257-0857\" \"(206) 390-9205\" \"(415) 385-1379\" \"(206) 779-0528\"\n```\n:::\n\n```{.r .cell-code}\nstr_detect(unique_phones, \"206\") %>% tail(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n\n## Replacement: `str_replace()`\n\nWhat about if you want to replace a string with something else? Use `str_replace()`!\n\n. . . \n\nThis function works very similarly to `str_detect()`, but with one extra argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace(string, pattern, replacement)\n```\n:::\n\n\n* `replacement` is what `pattern` is substituted for.\n\n. . . \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_replace(string = \"Hi, I'm Vic\",\n            pattern = \"Hi\", replacement = \"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello, I'm Vic\"\n```\n:::\n:::\n\n\n## Replacement: `str_replace()`\n\nIn the `Date` variable, let's replace each dash (\"-\") with an underscore (\"_\")\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- restaurants$`Inspection Date`\ndates %>% \n  tail(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"01/23/2023\" \"01/23/2023\" \"07/28/2022\"\n```\n:::\n\n```{.r .cell-code}\nstr_replace(dates, \"/\", \"_\") %>% \n  tail(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"01_23/2023\" \"01_23/2023\" \"07_28/2022\"\n```\n:::\n:::\n\n\nWait, what?\n\n## Replacement: `str_replace_all()`\n\n`str_replace()` only changes the **first** instance of a pattern in each string! \n\n. . . \n\nIf we want to replace **all** patterns, use `str_replace_all()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndates <- restaurants$`Inspection Date`\ndates %>% tail(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"01/23/2023\" \"01/23/2023\" \"07/28/2022\"\n```\n:::\n\n```{.r .cell-code}\nstr_replace_all(dates, \"/\", \"_\") %>% \n  tail(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"01_23_2023\" \"01_23_2023\" \"07_28_2022\"\n```\n:::\n:::\n\n\n## Quick Summary\n\nWe've seen lots of functions today! \n\n*Don't try to memorize them!* Instead, use this page as a reference.\n\n* Character Length: `nchar` and `str_length`\n* Subsetting: `substr` and `str_sub`\n* Combining: `paste` and `str_c`\n* Case Changes: `str_to_upper()`, `str_to_lower()`, and `str_to_title()`\n* Removing Whitespace: `str_trim`\n* Pattern Detection/Replacement: `str_detect()` and `str_replace()`\n\n## Activity 1: Base R Functions\n\nThe variable `Inspection Date` is in the format \"MM/DD/YYYY\". In this question, we'll change the format using functions for strings.\n\n1. How long is each character string in this variable?\n2. Use `substr()` to extract the month of each entry and save it to an object called \"months\"\n3. Use `substr()` to extract the year of each entry and save it to an object called \"years\"\n4. Use `paste()` to combine each month and year, separated by an underscore (`_`). Save this as a new variable in the data called \"Inspection_Date_Formatted\"\n\n## Activity: Answers\n\nThe variable `Inspection_Date` is in the format \"MM/DD/YYYY\". In this question, we'll change the format using functions for strings.\n\n1. How long is each character string in this variable?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(nchar(restaurants$`Inspection Date`))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    10 \n254624 \n```\n:::\n:::\n\n\n. . . \n\n2. Use `substr()` to extract the month of each entry and save it to an object called \"months\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonths <- substr(restaurants$`Inspection Date`, 1, 2)\nmonths |> \n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"03\" \"03\" \"08\" \"08\" \"01\"\n```\n:::\n:::\n\n\n## Activity: Answers\n\n3. Use `substr()` to extract the year of each entry and save it to an object called \"years\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyears <- substr(restaurants$`Inspection Date`, 7, 10)\nyears |> \n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023\" \"2023\" \"2022\" \"2022\" \"2022\"\n```\n:::\n:::\n\n\n. . . \n\n4. Use `paste()` to combine each month and year, separated by an underscore (`_`). Save this as a new variable in the data called \"Inspection_Date_Formatted\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrestaurants$Inspection_Date_Formatted <- paste(months, years, sep = \"_\")\n\nrestaurants %>% \n  select(Name, `Inspection Date`, Inspection_Date_Formatted) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  Name             `Inspection Date` Inspection_Date_Formatted\n  <chr>            <chr>             <chr>                    \n1 #807 TUTTA BELLA 03/02/2023        03_2023                  \n2 #807 TUTTA BELLA 03/02/2023        03_2023                  \n3 #807 TUTTA BELLA 08/31/2022        08_2022                  \n4 #807 TUTTA BELLA 08/31/2022        08_2022                  \n5 #807 TUTTA BELLA 01/13/2022        01_2022                  \n```\n:::\n:::\n\n\n## Activity 2: HW 8\n\nLet's examine the coffee shops of King County!\n\n1. Filter your data to only include rows in which the `Name` includes the word \"coffee\" (in any case!)\n\n2.. Create a new variable in your data which includes the length of the business name, after removing beginning/trailing whitespace.\n\n3. Create a new variable in your data for the inspection year, *using a `stringr` function!*\n\n4. Create side-by-side boxplots for the length of business name vs. year.\n\n5. Calculate the maximum `Inspection Score` by business and year.\n\n6. Create a line plot of maximum score (\"MaxScore\") over time (\"Year\"), by business (\"Name\"). That is, you should have a single line for each business. (Don't try to label them, as there are far too many!)\n\n## Activity: Solutions\n\n1\\. Filter your data to only include rows in which the `Name` includes the word \"coffee\" (in any case!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee <- restaurants\ncoffee$Name <- str_to_lower(coffee$Name)\ncoffee <- coffee %>% \n  filter(str_detect(Name, \"coffee\"))\ncoffee |> \n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 25\n  Name          `Program Identifier` `Inspection Date` Description Address City \n  <chr>         <chr>                <chr>             <chr>       <chr>   <chr>\n1 203 degrees … 203 DEGREES FAHRENH… 06/08/2023        Seating 13… 11901 … KIRK…\n2 203 degrees … 203 DEGREES FAHRENH… 06/08/2023        Seating 13… 11901 … KIRK…\n3 203 degrees … 203 DEGREES FAHRENH… 01/26/2022        Seating 13… 11901 … KIRK…\n4 203 degrees … 203 DEGREES FAHRENH… 08/11/2021        Seating 13… 11901 … KIRK…\n5 203 degrees … 203 DEGREES FAHRENH… 01/23/2020        Seating 13… 11901 … KIRK…\n# ℹ 19 more variables: `Zip Code` <dbl>, Phone <chr>, Longitude <dbl>,\n#   Latitude <dbl>, `Inspection Business Name` <chr>, `Inspection Type` <chr>,\n#   `Inspection Score` <dbl>, `Inspection Result` <chr>,\n#   `Inspection Closed Business` <lgl>, `Violation Type` <chr>,\n#   `Violation Description` <chr>, `Violation Points` <dbl>, Business_ID <chr>,\n#   Inspection_Serial_Num <chr>, Violation_Record_ID <chr>, Grade <dbl>,\n#   ZIP_5 <chr>, mailing_address <chr>, Inspection_Date_Formatted <chr>\n```\n:::\n:::\n\n\n## Activity: Solutions\n\n2\\.Create a new variable in your data which includes the length of the business name, after removing beginning/trailing whitespace.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee$NameLength <- str_length(str_trim(coffee$Name))\ncoffee |> \n  select(Name, NameLength) |> \n  slice(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   Name                          NameLength\n   <chr>                              <int>\n 1 203 degrees fahrenheit coffee         29\n 2 203 degrees fahrenheit coffee         29\n 3 203 degrees fahrenheit coffee         29\n 4 203 degrees fahrenheit coffee         29\n 5 203 degrees fahrenheit coffee         29\n 6 203 degrees fahrenheit coffee         29\n 7 909 coffee and wine                   19\n 8 909 coffee and wine                   19\n 9 909 coffee and wine                   19\n10 909 coffee and wine                   19\n```\n:::\n:::\n\n\n## Activity: Solutions\n\n3\\. Create a new variable in your data for the inspection year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee$Year <- str_sub(coffee$`Inspection Date`,-4,-1)\ncoffee$Year |> \n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2023\" \"2023\" \"2022\" \"2021\" \"2020\"\n```\n:::\n:::\n\n\n## Activity: Solutions\n\n4\\.  Create side-by-side boxplots for the length of business name vs. year.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(coffee, aes(Year, NameLength)) + \n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](CSSS508_Lecture8_files/figure-revealjs/unnamed-chunk-27-1.svg){fig-align='center'}\n:::\n:::\n\n\n## Activity: Solutions\n\n5\\. Calculate the maximum `Inspection Score` by business and year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee_summary <- coffee %>% \n  group_by(Name, Year) %>% \n  summarize(MaxScore = max(`Inspection Score`))\ncoffee_summary |> \n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n# Groups:   Name [1]\n  Name                          Year  MaxScore\n  <chr>                         <chr>    <dbl>\n1 203 degrees fahrenheit coffee 2019         0\n2 203 degrees fahrenheit coffee 2020        10\n3 203 degrees fahrenheit coffee 2021         0\n4 203 degrees fahrenheit coffee 2022         0\n5 203 degrees fahrenheit coffee 2023        15\n```\n:::\n:::\n\n\n## Activity: Solutions\n\n6\\. Create a line plot of maximum score (\"MaxScore\") over time (\"Year\"), by business (\"Name\"). That is, you should have a single line for each business. (Don't try to label them, as there are far too many!)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(coffee_summary, aes(Year, MaxScore, group = Name)) +\n  geom_line(alpha = .2)\n```\n\n::: {.cell-output-display}\n![](CSSS508_Lecture8_files/figure-revealjs/unnamed-chunk-29-1.svg){fig-align='center'}\n:::\n:::\n\n\n## Due Dates\n\n* **Section AA:** \n  + Homework #4 due Tuesday, November 28st (before lecture)\n  + Peer grading due Sunday, December 3rd (by 4:30pm)\n\n<br>\n\n* **Section AB:** \n  + Homework #4 due Thursday, November 30th (before lab)\n  + Peer grading due Tuesday, December 5th (before lecture)\n",
    "supporting": [
      "CSSS508_Lecture8_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}